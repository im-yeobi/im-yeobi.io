---
title: "[알고리즘 문제풀이] 백준 1145번 - Java 풀이"
date: "2020-02-27T11:10"
template: "post"
draft: false
slug: "/posts/algorithm/problem-solving/0003-baekjoon-1145/"
category: "알고리즘 문제풀이"
tags:
  - "알고리즘 문제풀이"
  - "백준"
  - "탐색"
description: "다섯 개의 자연수가 있다. 이 수의 적어도 대부분의 배수는 위의 수 중 적어도 세 개로 나누어 지는 가장 작은 자연수이다. 서로 다른 다섯 개의 자연수가 주어질 때, 적어도 대부분의 배수를 출력하는 프로그램을 작성하시오."
---

## 문제 출처

[백준 1145번 - 적어도 대부분의 배수](https://www.acmicpc.net/problem/1145)


## 문제 유형

- `탐색`
- `완전 탐색`


## 문제

다섯 개의 자연수가 있다. 이 수의 적어도 대부분의 배수는 위의 수 중 적어도 세 개로 나누어 지는 가장 작은 자연수이다.
<br />
서로 다른 다섯 개의 자연수가 주어질 때, 적어도 대부분의 배수를 출력하는 프로그램을 작성하시오.

**입력**
<br />
첫째 줄에 다섯 개의 자연수가 주어진다. 100보다 작거나 같은 자연수이고, 서로 다른 수이다.

**출력**
<br />
첫째 줄에 적어도 대부분의 배수를 출력한다.

**에제 입력**

```
30 42 70 35 90
```

**예제 출력**

```
210
```


## 문제 풀이

해당 문제는 `완전 탐색` 알고리즘을 사용해서 풀 수 있다. 문제에서 `5개의 자연수`가 주어지고, `100 이하의 서로 다른 자연수`라는 조건을 주었으니, 그 안에서 탐색을 수행하면 된다.
<br />
최소 세 개 자연수의 `최소 공배수`를 구하는 것이 문제에서 요구하는 결과이니, 탐색 시작 조건과 종료 조건을 생각해보자.

- **시작 조건** : 1부터 탐색을 시작할 수도 있지만, 다섯 개 자연수 중 `최소값`부터 시작할 수 있다.
- **종료 조건** : 최소 3개의 자연수로 나누어지는 값. 100이하의 서로 다른 자연수이기 때문에, 아무리 커봐야 세 개 자연수의 최소 공배수는 `100 * 99 * 98 = 970,200`이다.

실제 코드에서는 while 문을 이용해 `최소값`부터 탐색을 한다. 그리고 while문의 종료는 최소 공배수의 최대값인 970,200을 지정하지 않고, 적어도 세 개의 자연수로 나누어지는 경우를 `탈출 조건`으로 사용했다.
<br />
아래 코드가 위 조건을 포함하는 완전 탐색 구문이다.

```java
while (true) {  // 나올 수 있는 가장 큰 값은 100 * 99 * 98 = 970,200
  for (int i = 0; i < SIZE; i++) {
    if (min % arr[i] == 0) cnt++;
  }

  // 적어도 세 개의 자연수로 나누어지는 경우 반복문 탈출
  if (cnt >= 3) break;

  cnt = 0;
  min++;
}
```


## 소스 코드

```java
import java.util.Scanner;

public class LeastMultiple {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int SIZE = 5;
    // 5개의 자연수
    int[] arr = new int[SIZE];
    int min = 100;

    // 자연수 입력. 100보다 작거나 같은 서로 다른 자연수
    for (int i = 0; i < SIZE; i++) {
      arr[i] = sc.nextInt();

      if (min > arr[i]) {
        min = arr[i];
      }
    }

    int cnt = 0;
    while (true) {  // 나올 수 있는 가장 큰 값은 100 * 99 * 98 = 970,200
      for (int i = 0; i < SIZE; i++) {
        if (min % arr[i] == 0) cnt++;
      }

      // 적어도 세 개의 자연수로 나누어지는 경우 반복문 탈출
      if (cnt >= 3) break;

      cnt = 0;
      min++;
    }

    System.out.println(min);
  }
}
```

> 전체 코드는 [Github](https://github.com/im-yeobi/algorithm/tree/master/algorithm/problem-solving/src/main/java/search/baekjoon/_1145)을 확인해주세요.