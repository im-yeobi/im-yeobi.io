---
title: "[자바의 정석] Chapter 06. 객체지향 프로그래밍(OOP) 1"
date: "2019-12-12T10:02"
template: "post"
draft: false
slug: "/posts/java/book/standard-of-java/ch06-oop-1/"
category: "Java"
tags:
  - "Java"
  - "자바의 정석"
  - "OOP"
description: "객체지향이론의 기본 개념은 '실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용'이다."
---

## 1. 객체지향언어

### 1.1 객체지향언어의 역사

초창기의 과학자들은 모의 실험을 위해 실제 세계와 유사한 가상 세계를 컴퓨터 속에 구현하고자 노력, 이러한 노력으로 객체지향이론 탄생
<br />
객체지향이론의 기본 개념 `실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.`
<br />
객체지향이론은 상속, 캡슐화, 추상화 개념을 중심으로 점차 구체적으로 발전되었으며, 1960년대 중반 객체지향이론을 프로그래밍언어에 적용한 `시뮬라(Simula)`라는 최초의 객체지향언어 탄생.



### 1.2 객체지향언어

`객체지향언어는 기존의 프로그래밍언어와 다른 완전히 새로운 것이 아니라, 기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가한 보다 발전된 형태의 것이다.`
<br />
규칙들을 이용해서 코드 간에 `서로 관계를 맺어줌으로써` 보다 유기적으로 프로그램을 구성하는 것이 가능해졌다.

```
객체지향언어의 주요 특징

1. 코드의 재사용성이 높다.
    - 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다.
2. 코드의 관리가 용이하다.
    - 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
3. 신뢰성이 높은 프로그래밍을 가능하게 한다.
    - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 
            코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.

=> 객체지향의 가장 큰 장점은 '코드의 재사용성이 높고 유지보수가 용이하다'는 것이다.
=> 객체지향개념을 학습할 때 재사용성과 유지보수 그리고 중복된 코드의 제거, 이 세 가지 관점에서 보면 쉽게 이해할 수 있다.
```


## 2. 클래스와 객체

### 2.1 클래스와 객체의 정의와 용도

```
클래스의 정의 — 클래스란 객체를 정의해 놓은 것이다.
클래스의 용도 — 클래스는 객체를 생성하는데 사용된다.

객체의 정의 — 실제로 존재하는 것. 사물 또는 개념
객체의 용도 — 객체가 가지고 있는 기능과 속성에 따라 다름

유형의 객체 — 책상, 의자, 자동차, TV와 같은 사물
무형의 객체 — 수학공식, 프로그램 에러와 같은 논리나 개념
```

`프로그래밍에서` 객체는 클래스에 정의된 내용대로 메모리에 생성되는 것을 뜻한다.
<br />
객체를 사용한다는 것은 객체가 가지고 있는 속성과 기능을 사용한다는 뜻이다.


### 2.2 객체와 인스턴스

인스턴스화 — 클래스로부터 객체를 만드는 과정
<br />
인스턴스 — 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라 한다.

```
클래스 ==인스턴스화==> 인스턴스(객체)
```


### 2.3 객체의 구성요소 — 속성과 기능

객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있으며, 일반적으로 객체는 다수의 속성과 다수의 기능을 갖는다. 객체는 `속성과 기능의 집합`이다.

```
속성(property) — 멤버변수, 특성, 필드, 상태
기능(function) — 메서드, 함수, 행위
```

### 2.3 인스턴스의 생성과 사용

```
Book book;  // 참조변수 선언
book = new Book();  // 인스턴스 생성, 객체의 주소를 참조변수에 저장
```


### 2.4 클래스의 또 다른 정의

프로그래밍 언어에서 데이터 처리를 위한 데이터 저장 형태의 발전과정

```
1. 변수 — 하나의 데이터를 저장할 수 있는 공간
2. 배열 — 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. 구조체 — 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. 클래스 — 데이터와 함수의 결합 (구조체 + 함수)
```

프로그래밍 언어에서 제공하는 자료형(`primitive type`) 외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 `사용자정의 타입(user-defined type)`이라고 한다.


## 3. 변수와 메소드

### 3.1 선언 위치에 따른 변수의 종류

변수는 클래스 변수, 인스턴스 변수, 지역 변수 모두 세 종류가 있다. 변수의 종류를 결정짓는 중요한 요소는 `변수의 선언된 위치` 이다.

- 인스턴스 변수

  - 클래스 영역에 선언
  - `인스턴스가 생성될 때 만들어진다` .
  - 인스턴스마다 고유한 상태를 유지해야 하는 속성의 경우, 인스턴스 변수로 선언한다.

- 클래스 변수

  - 클래스 영역에 선언

  - `클래스가 메모리에 로딩 될 때 생성되어 프로그램이 종료될 때 까지 유지된다`.

  - 클래스 변수를 선언하는 방법은 인스턴스 변수 앞에 static 키워드 붙인다.

  - 인스턴스 변수와 달리 모든 인스턴스가 `공통된 저장공간(변수)을 공유`한다.

  - 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있다.

    ```java
    Book.saleCount  // 클래스이름.클래스변수
    ```

- 지역 변수
  - 메서드 내에 선언되어 메서드 내에서만 사용 가능하다.
  - 메서드가 종료되면 소멸된다.


### 3.2 메서드 (method)

메서드는 `특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것`이다.

내부적으로 어떤 과정을 거쳐 결과를 만들어내는지 전혀 몰라도 된다. (println(), random() 메서드)

#### 메서드를 사용하는 이유

#### i. 높은 재사용성
- 한번 만들어 놓은 메서드를 몇 번이고 호출할 수 있다.

#### ii. 중복된 코드의 제거
- 반복되는 문장들을 메서드로 작성한다.
- 전체 소스 길이가 짧아진다.
- 변경사항 발생했을 때 수정해야할 코드의 양이 줄어든다. (메서드 내용만 수정하면 됨)

#### iii. 프로그램의 구조화
- 큰 규모의 프로그램에서는 문장들을 `작업단위`로 나눠서 여러 개의 메서드에 담아 프로그램의 구조를 단순화시키는 것이 필수적이다.
- 처음에 프로그램을 설계할 때 `내용이 없는 메서드를 작업단위로 만들어 놓고`, 하나씩 완성해가는 것도 프로그램을 구조화 하는 좋은 방법이다.


### 3.3 메서드의 선언과 구현

메서드는 크게 두 부분 `선언부(header)` 와 `구현부(body)`로 이루어져 있다.

#### return 문

작업을 수행한 결과인 반환값을 호출한 메서드로 전달.
<br />
이 값의 타입은 반환타입과 일치하거나, 자동 형변환이 가능한 것이어야 한다.


### 3.4 메서드의 호출

#### 인자(argument)와 매개변수(parameter)

메서드를 호출할 때 괄호() 안에 지정해준 값들을 `인자(argument)` 또는 `인수`라고 한다. 
<br />
메서드에 선언된 `매개변수(parameter)`
<br />
static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다. ⇒ 클래스가 메모리에 로딩되는 시점에 인스턴스 존재하지 않을 수 있기 때문이다. 인스턴스 생성하여 사용 가능하다.


### 3.5 return 문

return문은 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다. 반환타입이 void인 경우, `컴파일러가 메서드의 마지막에 'return;'을 자동적으로 추가`해준다.

#### 매개변수의 유효성 검사

메서드의 구현부{}를 작성할 때, 제일 먼저 해야 하는 일이 매개변수의 값이 적절한 것인지 확인하는 것이다.  ⇒ 유효성 검사
<br />
매개변수에 대한 가능한 모든 경우의 수에 대해 고민하고 그에 대비한 코드를 작성해야 한다.


### 3.6 JVM의 메모리 구조

응용프로그램이 실행되면 JVM은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당받고 JVM은 이 메모리를 용도에 따라 여러 영역으로 나누어 관리한다. method area, call stack, heap

- 메서드 영역 (method area)
    - 프로그래밍 실행 중 어떤 클래스가 사용되면 JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보(클래스 데이터)를 이곳에 저장한다. 클래스의 클래스 변수도 이 영역에 함께 생성된다.
- 힙 (heap)
    - 인스턴스가 생성되는 공간. `런타임에 크기가 결정`된다. 인스턴스 변수들이 생성되는 공간이다. 가비지 컬렉터에 의해 관리된다.
- 호출스택 (call stack)
    - 메서드 작업에 필요한 메모리 공간을 제공한다. `컴파일 타임에 크기 결정`된다. 메서드가 작업을 마치면 할당되었던 메모리공간은 반환된다.
    - 호출스택의 제일 상위에 위치하는 메서드가 현재 실행 중인 메서드이다.
    - 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.


### 3.7 기본형 매개변수와 참조형 매개변수

- 기본형 매개변수 — 변수의 값을 읽기만 할 수 있다. (read only)
- 참조형 매개변수 — 변수의 값을 읽고 변경할 수 있다. (read & write)


### 3.8 재귀호출 (recursive call)

메서드의 내부에서 메서드 자신을 다시 호출하는 것을 재귀호출이라 한다.

    void method() {
        method();  // 재귀호출
    }

대부분의 재귀호출은 반복문으로 작성하는 것이 가능하다.

재귀호출은 반복문보다 몇 가지 과정이 더 필요하다. ⇒ 매개변수 복사와 종료 후 복귀할 주소 저장 등이 추가로 필요하기 때문에 `반복문보다 재귀호출의 수행시간이 더 오래 걸린다`. 하지만 재귀호출이 주는 `논리점 간결함` 때문에 재귀호출 사용.

재귀호출은 비효율적이므로 재귀 호출에 드는 비용보다 `재귀호출의 간결함`이 주는 이득이 충분히 큰 경우에만 사용해야 한다.


### 3.9 클래스 메서드(static 메서드)와 인스턴스 메서드

인스턴스 메서드는 메서드의 작업을 수행하는데 `인스턴스 변수를 필요`로 하는 메서드이다.
<br />
인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드를 클래스 메서드로 정의한다.
<br />
물론, 인스턴스 변수를 사용하지 않는다고 해서 반드시 클래스 메서드로 정의해야 하는 것은 아니지만, 특별한 이유가 없는 한 그렇게 하는 것이 일반적이다.
<br />
멤버변수는 클래스 변수와 인스턴스 변수 모두 통칭하는 말이다.

#### i. 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.

#### ii. 클래스 변수는 인스턴스를 생성하지 않아도 사용할 수 있다.
- static이 붙은 클래스 변수는 `클래스가 메모리에 올라갈 때 이미 자동적으로 생성`되기 때문이다.

#### iii. 클래스 메서드는 인스턴스 변수를 사용할 수 없다.
- 인스턴스 생성 없이 호출 가능하므로, 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다.

#### iv. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.
- static 메서드는 메서드 호출 시간이 짧아지므로 성능이 향상된다. 인스턴스 메서드는 실행 시 `호출되어야 할 메서드를 찾는 과정`이 추가적으로 필요하기 때문에 시간이 더 걸린다.

```java
- 클래스의 멤버변수 중 모든 인스턴스에 고통된 값을 유지해야 하는 것이 있는지 살펴보고 있으면, static을 붙여준다. 
- 작성한 메서드 중에서 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드에 static을 붙일 것을 고려한다.
```


### 3.10 클래스 멤버와 인스턴스 멤버간의 참조와 호출

같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조 또는 호출이 가능하다. 단, `클래스멤버가 인스턴스 멤버를 참조 또는 호출`하고자 하는 경우에는 인스턴스를 생성해야 한다.
<br />
그 이유는 `인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재`하지만, `클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도` 있기 때문이다.
- 같은 클래스 내에서 클래스 멤버(메서드, 변수) 인스턴스 멤버를 참조 또는 호출해야하는 경우는 드물다. 만일 그런 경우가 발생한다면, 인스턴스 메서드로 작성해야 할 메서드를 클래스 메서드로 한 것은 아닌지 한 번 더 생각해봐야 한다.


## 4. 오버로딩

### 4.1 오버로딩이란 ?

한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 `오버로딩`이라고 한다. 이름은 같지만 매개변수의 개수 또는 타입이 다르다. 하나의 메서드 이름으로 여러 기능을 구현하기 때문에 붙여진 이름.
<br />
오버로딩의 대표적인 예는 println 메서드이다.
<br />
같은 일을 하지만 매개변수를 달리 해야하는 경우에 오버로딩을 구현한다.


### 4.2 오버로딩의 조건

- 메서드 이름이 같아야 한다.
- 매개변수의 개수 또는 타입이 달라야 한다.
- 반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다.
  

### 4.3 오버로딩의 장점

- 기억하기 쉽고 이름도 짧게 할 수 있어서 오류의 가능성을 줄일 수 있다.
- 메서드의 이름만 보고도 '이 메서드들은 이름이 같으니, 같은 기능을 하겠구나'라고 쉽게 예측 가능.
- 메서드의 이름 절약할 수 있다.


### 4.4 가변인자와 오버로딩

기존에는 메서드의 매개변수 개수가 고정적이었으나 JDK1.5부터 동적으로 지정해 줄 수 있게 되었으며, 이 기능을 '가변인자(variable arguments)'라고 한다.
<br />
가변인자 외에도 매개변수가 더 있다면, `가변인자를 매개변수 중에서 제일 마지막에 선언`해야 한다. 가변인자인지 아닌지를 구별할 방법이 없기 때문에 허용하지 않는다.
<br />
가변인자는 내부적으로 배열을 이용한다. 가변인자로 선언된 메서드는 호출할 때마다 배열이 새로 생성된다. (비효율)

#### 매개변수 타입을 배열로 하는 것과 차이
- 매개변수 타입을 배열로 하면 반드시 인자를 지정해 줘야 한다.
- 인자 생략 불가능
- null이나 길이가 0인 배열, 인자 지정해줘야 함

가능하면 가변인자를 사용한 메서드는 오버로딩 하지 않는 것이 좋다.


## 5. 생성자 (Constructor)

### 5.1 생성자란?

생성자는 인스턴스가 생성될 때 호출되는 `인스턴스 초기화 메서드`이다.
<br />
인스턴스 변수의 초기화 작업에 주로 사용되며, `인스턴스 생성 시에 실행되어야 할 작업`을 위해서도 사용된다.

#### 생성자의 조건 
- i. 생성자의 이름은 클래스의 이름과 같아야 한다. 
- ii. 생성자는 리턴 값이 없다.

연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다. 생성자는 단순히 인스턴스 변수들의 초기화에 사용되는 조금 특별한 메서드일 뿐이다.

```
인스턴스 생성 과정
Card c = new Card();

i. 연산자 new에 의해서 메모리(heap)에 Card 클래스의 인스턴스가 생성된다.
ii. 생성자 Card()가 호출되어 수행된다.
iii. 연산자 new의 결과로, 생성된 Card 인스턴스의 주소가 반환되어 참조변수 C에 저장된다.
```


### 5.2 기본 생성자 (default constructor)

생성자가 하나도 정의되어 있지 않은 경우 컴파일러가 기본 생성자(default constructor)를 제공한다.
<br />
컴파일러가 자동적으로 기본 생성자를 추가해주는 경우는 `클래스 내에 생성자가 하나도 없을 때` 뿐이다.


### 5.3 매개변수 있는 생성자

인스턴스를 생성한 다음에 인스턴스 변수의 값을 변경하는 것보다 `매개변수를 갖는 생성자를 사용하는 것이 코드를 보다 간결하고 직관적으로 만든다.`
<br />
클래스를 작성할 때 다양한 생성자를 제공함으로써 `인스턴스 생성 후에 별도로 초기화를 하지 않아도` 되도록 하는 것이 바람직하다.


### 5.4 생성자에서 다른 생성자 호출하기 - this(), this

```
- 생성자의 이름으로 클래스이름 대신 this를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
```

#### 다른 생성자를 `첫 줄에서만 호출 가능한 이유`
⇒ 생성자 내에서 초기화 작업 도중에 다른 생성자를 호출하게 되면, 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화 할 것이므로 `다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질`  수 있기 때문이다.

`this` 는 참조변수로 인스턴스 자신을 가리킨다. this를 사용할 수 있는 것은 인스턴스 멤버뿐이다. static 메서드에서는 this를 사용할 수 없다. static 메서드가 호출된 시점에 인스턴스가 존재하지 않을 수도 있기 때문이다.
<br />
생성자를 포함한 모든 인스턴스 메서드에는 자신이 관련된 인스턴스를 가리키는 참조변수 this가 지역변수로 숨겨져 있다.

```
this — 인스턴스 자신을 가리키는 참조변수, 인스턴스의 주소가 저장되어 있다. 
			 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재한다.
this(), this(매개변수) — 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.
```

생성자를 활용하면 보다 간결하고 직관적인, 객체지향적인 코드를 작성할 수 있다.
```
인스턴스를 생성할 때는 다음의 2가지 사항을 결정해야 한다.
i. 클래스 : 어떤 클래스의 인스턴스를 생성할 것인가 ?
ii. 생성자 : 선택한 클래스의 어떤 생성자로 인스턴스를 생성할 것인가 ?
```


## 6. 변수의 초기화

### 6.1 변수의 초기화

선언과 동시에 적절한 값으로 초기화 하는 것이 바람직하다.
<br />
멤버변수는 초기화를 하지 않아도 자동적으로 `변수의 자료형에 맞는 기본값으로 초기화`가 이루어진다. 지연변수는 사용하기 전에 반드시 초기화를 해야 한다.

```
멤버변수(클래스변수와 인스턴스변수)와 배열의 초기화는 선택적이지만, 지역변수의 초기화는 필수적이다.

멤버변수의 초기화 방법
1. 명시적 초기화 (explicit initialization)
2. 생성자 (constructor)
3. 초기화 블럭 (initialization block)
	- 인스턴스 초기화 블럭 : 인스턴스 변수 초기화
  - 클래스 초기화 블럭 : 클래스(static) 변수 초기화
```


### 6.2 명시적 초기화 (explicit initialization)

변수를 선언과 동시에 초기화하는 것을 명시적 초기화라고 한다.


### 6.3 초기화 블럭 (initialization block)

```
클래스 초기화 블럭 — 클래스 변수의 복잡한 초기화에 사용된다.
class StaticBlock {
	static { /* 클래스 초기화 블럭 */ }
}

인스턴스 초기화 블럭 — 인스턴스 변수의 복잡한 초기화에 사용된다.
class InstanceBlock {
	{ /* 인스턴스 초기화 블럭 */ }
}
```

초기화 작업이 복잡하여 명시적 초기화만으로는 부족한 경우 초기화 블럭을 사용한다.

#### 클래스 초기화 블럭

클래스 초기화 블럭은 클래스가 `메모리에 처음 로딩될 때 한번`만 수행된다. 
<br />
클래스가 처음 로딩될 때 클래스 변수들이 자동적으로 메모리에 만들어지고, 곧바로 클래스 초기화 블럭이 클래스 변수들을 초기화하게 된다.

#### 인스턴스 초기화 블럭

생성자보다 인스턴스 초기화 블럭이 먼저 수행된다. 
<br />
인스턴스 변수의 초기화는 주로 생성자를 사용하고, 인스턴스 초기화 블럭은 모든 생성자에서 공통으로 수행되어야 하는 코드를 넣는데 사용한다.


### 6.4 멤버변수의 초기화 시기와 순서

```
클래스 변수의 초기화 시점 — 클래스가 처음 로딩될 때 단 한번 초기화 된다.
인스턴스 변수의 초기화 시점 — 인스턴스가 생성될 때마다 각 인스턴스별로 초기화가 이루어진다.

클래스 변수의 초기화 순서 — 기본값 => 명시적 초기화 => 클래스 초기화 블럭
인스턴스 변수의 초기화 순서 — 기본값 => 명시적 초기화 => 인스턴스 초기화 블럭 => 생성자
```

클래스의 로딩 시기는 JVM의 종류에 따라 다르다. 클래스가 `필요할 때 바로 메모리에 로딩`하도록 설계가 되어있는 것도 있고, `실행효율을 높이기 위해서 사용될 클래스들을 프로그램이 시작될 때 미리 로딩`하도록 되어있는 것도 있다.
